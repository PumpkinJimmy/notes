## C++ 面向对象
### static
static在类里面用于声明静态类成员与静态成员函数。

静态类成员一个类只有一份（而不是每个实例都有一份）

1. 静态类成员
   - 在类定义内里加上static，初始化时不用加
   - 其本质是全局/静态区的全局变量，生存期是整个程序运行期间，**不随实例析构而析构**
   - 类似全局变量，需要手动初始化
   - 一般在**类定义以外**初始化（且一般在全局区初始化），语法同一般全局变量的定义，只要再加上类作用域符号
   - 访问控制只限制访问，**类外初始化不受影响**
   - 若是`const static`则可以在类定义内初始化
   - 小心重复初始化，不要在头文件里编写静态类成员初始化
2. 静态成员函数
   - 在类定义内里加上static，编写成员函数的实现时不用加
   - 没有this指针
   - 可以直接访问静态类成员
   - 可以直接访问类作用域来调用，不需要实例
3. 一个应用：实现单例模式
   ```cpp
   // singleton.h
   class Singleton
   {
    private:
        Singleton();
        Singleton& Singleton(const Singleton&);
        Singleton& operator=(const Singleton&);
        static Singleton* instance;
    public:
        static Singleton* getInstance();
   };
   // singleton.cpp
   Singleton* Singleton::instance = nullptr;
   Singleton* Singleton::getInstance()
   {
       if (instance == nullptr)
           instance = new Singleton;
           return instance;
   }
   ```

### 多态
- 运行时多态的典型实现是虚函数表，本质上就是函数指针：同一个接口，不同的行为
- C++的具体编码中，多态需要通过虚函数+继承+指针/引用来实现
- 在很多情形下，多态需要指针来体现，故常常面临内存管理问题（如指针指向的内存需要动态分配，使得构造函数的得不到正确的参数），处理的常见技巧如下：
  1. 智能指针（用`unique_ptr<>`来移交内存所有权，`shared_ptr<>`无脑解决），缺点是要套智能指针，烦
  2. 工厂方法/抽象工厂，直接用工厂组装好再交给使用多态特性的用户类，缺点是容易出错

### 移动语义
> 拷贝的代价是高昂的
- 在典型的C++ OOP里面，`const&`是万金油的形参：对匹配的类型的左值和右值直接传引用，对可以转换的类型创建临时变量再传引用。`const&`通过传引用的方式令经典C函数的传参拷贝行为应用于引用而非对象本身，避免了代价高昂的对象拷贝，但其本质往往是*值语义*，最明显的就是复制构造函数，常引用虽然避免了传参的时候的拷贝，却避免不了参数对象拷贝到`this`里面。这往往是我们想要的（符合复制构造的直观语义，且对于临时对象这一拷贝是必要的），但有一个例外，也就是**类型匹配的右值**。对于类型匹配的右值，把传入的对象的数据拷贝到`this`里面的操作是多余的拷贝。最简洁的方法其实是直接将右值引用绑定的内存的所有权*移交*给this，避免复制。这就是移动语义的目标。
- 移动语义实现的关键技术是*右值引用*。通过将函数重载为具有右值引用的形参的形式，C++允许用户区分出“传入右值”这种特殊情况并针对这种情况进行编程。
- 给出右值引用函数重载就是实现移动语义
- 移动语义的引入带来了两个特殊方法（它们都有默认实现）：移动构造函数
- C++标准库普遍实现了移动语义
- `std::move`等价于`static_cast<T&&>`，用于将一个左值强制转换成右值引用，实现强制移动语义
- 注意：尽管将形参声明为右值引用，但参数实际上的类型是*左值引用*，也就是说必须强制移动（`std::move`），例如：
  ```cpp
  void b(const int& x){
    "Copy semantics";
  }
  void b(int&& x){
    "Move semantics";
  }
  void a(int&& x){
    b(x); // Copy
    b(std::move(x)) // Move
  }
  ```

### Range-based For
形如
```cpp
for (auto x: container){
  // loop statement
}
```
的语句称为Range-based For
只要`container`对象提供begin()跟end()方法，且返回的迭代器是可以实现了自增运算符的，就可以使用这个语句。

### 杂项
- `override`关键字可以放在方法声明的后面（分号前面），常与virtual方法搭配使用，表示这是一个重载的方法（编译器会检查，如果这个方法没有正确重载，将编译报错）
- 委托构造函数：允许在构造函数的成员初始化字段使用调用其他构造函数
  - 区分子类中调用父类构造函数
  - 一旦采用委托构造，初始化字段不能再进行成员变量的初始化
- `default`方法
  许多特殊方法编译器是可以给出默认实现的（包括），可以使用`方法=defualt`的语法避免手写，直接应用默认实现。
- `delete`方法
  应用于一些具有默认实现的特殊方法，`方法=delete`即表示删除该方法，效果等同于将其放在private里面