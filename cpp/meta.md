## C++元编程

> 关于“元数据”的编程

在编译器可以操作的所有数据，包括常量和类型，都是“元数据”。

元编程是关于元数据的编程
### 元函数
- 编译期多态
  
  对不同的类型采用相同的操作，其行为类似运行期的多态，称为“编译期多态”

  实际上，由于编译器不对类型“接口”做检查，所以类型多态本来是无限制的。

  所谓*编译期多态*是逻辑上/设计上的理念

  如果要落实到语法、编译器检查上，则涉及所谓的*concept*：在老C++里采用晦涩的SFINAE，在新C++里采用constexpr if / concept required

- Constant Wrapper（常量外覆器）
  
  本来编译器常量是模板参数的合法选择，但为了兼容“编译器多态”的理念，我们将一个常量包装为一个类型，该类型的`::value`为其值

- 元函数
  
  严格意义上的*元函数*是指以类型为参数，拥有一个`type`静态成员充当“返回值”的类模板。

  元函数调用：`meta_function<Arg1, Arg2>::type`在逻辑上类似函数调用`meta_function(Arg1, Arg2)`

  注意区分模板函数和元函数。模板函数是“函数模板”，元函数实际上是一个“类模板”。


- 元函数的编程方式
  
  - 元函数的编程方式类似“函数式编程”
  - 元函数的分支判断依赖偏特化
    
     如对模板参数`true_`跟`false_`分别偏特化，实质上就是在实现不同分支的行为
 
  - `if constexpr`降低了分支负担，可以直接做判断
  - 由于可变参数模板，元函数可以处理可变个参数的序列了。但元函数没有循环语法，它类似函数式编程，依赖*尾递归*实现循环逻辑
  - 出于多态的理念，返回值统一存放在`type`成员里面。但返回值往往是一个编译器常量而不是一个类型，此时反复`::value`取值就很麻烦。故标准元函数库的元函数往往提供`metafunction_v`的编译器常量版本，直接成为编译器常量

- 可变模板参数包
  
  - 使用`T... vals`声明可变的编译器常量参数；`typename... Types`声明可变的类型参数
  - 使用`vals...`以及`Types...`解包参数
  - 通常解包参数语法只用于传递，真正要取出其中的参数需要递归类模板

- `enable_if`
  可以认为`enable_if`的行为类似如下实现：
  ```cpp
  // template <bool enable, T Ty> struct enable_if;
  template <T Ty> struct enable_if<false, T> {};
  template <T Ty> struct enable_if<true, T> { typedef T type;}
  ```
  也就是说，通过偏特化，让enable为假时`type`未定义，从而让enable为false的模板实例化失败

  注1：通常结合*匿名默认模板参数*来使用

  注2：SFINAE的核心组件，本质上实现的是*concept*

  注3：可以考虑if constexpr代替

  注4：当enable=True时本质上type只是普通类型，注意重载问题

- 坑
  - `typename`的在`typedef`中的使用
    
    当`typedef`语句的第一个部分是`::`限定符限定的时候，必须使用`typename`，否则禁止使用`typename`