## 一般C++编程
### 全局变量
- 用函数返回值初始化全局变量/初始化对象从而调用构造函数是在main开始之前执行代码的方法。但要注意不同全局变量之间的初始化顺序是**不确定**的，小心相互依赖。
- 全局变量之可以定义一次，对应只分配一次全局区内存。多个文件中多次定义全局变量会导致重定义错误（除非使用static限定链接性）。但多个文件中使用全局变量要**声明**，语法是常规声明前面加extern如`extern int a`。声明要求本质上源于文件是*最小的编译单元*。
- 重定义的问题主要出现于在头文件中定义全局变量的做法。
- 函数定义有类似的问题，不要在头文件定义函数。
- 对于全局变量，正确做法是在头文件中写*声明*，在源文件中*定义*，然后链接
- 对于全局函数，两种做法：
  1. 头文件中*声明*，源文件中*定义*（标准做法）
  2. static定义
  3. inline（inline函数具有文件内的链接性）

### 列表初始化
C++11允许采用形如
```cpp
vector<int> vec = {1, 2, 3, 4};
map<int, string> = { {1, "a"}, {2, "b"} };
```
的列表初始化语法来初始化STL容器，可以大大方便容器的初始化。（上述语法中的等号可以省略）
还可以作为参数传递：
```cpp
map<int, string> mp;
mp.insert({3, "c"});
```

这种用法的奥秘在于：
1. 编译器的支持
2. initialize_list模板类支持变长的、任意类型的序列（尤其用于map这种每个项类型不一样的东西）

### 宏
宏可以用于移除一些重复代码，可以代码生成（语言体系内部不可替代），甚至用来编写DSL（慎）
用法：
- 分为一般宏和带参数宏
- 宏定义结尾不用写分号（如写上分号则当作是**宏体的一部分**），**一个宏定义只能写一行，多行情形必须加行连符号**
- 一般宏：
  - 使用`#define 宏名 宏体`定义
  - 宏体可以省略，常结合`#ifdef` `#ifndef`使用
  - 有部分预定义的宏如`__LINE__``__FILE__`分别表示所在行号、处理的文件名等
  - 可以由外部（如CMake等编译系统）传入用以在预处理阶段搞事（如条件编译）
- 带参数宏：
  - #的特殊用法：
  ```cpp
  #define STR(s) #s // 替换为"s"
  #define CONCAT(a,b) a##b // 替换为ab（连接起来）
  ```
  - 参数为宏时，这个宏会继续展开；特别地，宏体包含#用法时参数中的宏不会再展开，但可以通过一层间接宏来展开
  - 一个综合运用：
  ```cpp
  #define ___ANONYMOUS1(type, var, line) type var##line  
  #define __ANONYMOUS0(type,  line) ___ANONYMOUS1(type, _anonymous, line)  
  #define ANONYMOUS(type) __ANONYMOUS0(type, __LINE__)
  // 假设在第70行，ANONYMOUS(static int)展开为 static int _anonymous70
  ```

### 友元与继承
结论：友元与继承不能联合使用
解释：
- 基类友元不能访问子类私有
- 友元类子类同样没有访问特权

### 智能指针
- 智能指针不是普通指针的完全替代品，智能指针只用于**处理动态内存**的场合，在传参、迭代器、函数指针、多态等场合普通指针不能被其替代。
- 裸指针动态内存管理可以说是C/C++强大的根源之一，进程内对内存的管理完全自由，操作非常接近底层，允许非常底层的管理和优化，允许实现内存池之类自定义内存管理方案
- 裸指针的危害主要是：非法访问（“野指针”），内存泄露（动态内存没有得到回收），double-free（多次释放，试图释放别人的内存）
- 裸指针管理内存的不安全性的根源在于指针管理动态内存时，资源的管理是*任意的*，代码的*语义*是不明确的：
  - 在局部变量静态内存管理的场合，内存作为资源，其所有者是创建这个局部变量的函数，在函数返回时内存会自动回收，符合RAII，安全
  - 在动态内存场合，资源属于整个进程，进程内部对资源的管理是自由的、或者说是任意的，任何代码在任何位置都可以利用指针释放内存，但指向动态内存的指针的传递、访问都不受限制直至非法访问导致程序运行时错误。
  - 在动态内存场合，指向动态内存的指针有两种语义：弱引用和强引用
    - 弱引用是指**不具有资源的所有权**,**不负责管理内存**
    - 强引用**具有资源的所有权**，在引用失效时**负责回收内存**。
  - 裸指针的行为等效于*弱引用*，但指向动态内存的指针的*语义*是*不明确的*（也即两者皆有可能）
- 两种典型的智能指针：`unique_ptr<>` `shared_ptr<>`
  - 两种都是强引用，区别在于：`unique_ptr`在指针传递的同时移交所有权，在指针失效时就可以回收内存；`shared_ptr`进行引用计数，`shared_ptr`每次传递都使引用计数+1，资源在没有引用，也就是引用计数归0被回收。某种意义上来说，`shared_ptr`是`unique_ptr`的上位替代。
  - 但`shared_ptr`的引用计数方案存在循环计数的隐患。考虑堆上的两块内存相互引用，即使这两块内存都没有其他引用了，但引用计数都没法归0，也就是内存泄漏了。解决方法是引入`weak_ptr<>`，其在行为上与普通指针完全相同，也就是不进行引用计数，不影响资源的生命周期

### 编码与中文处理
众所周知中文作为多字节语言，其编码是个大坑点。
编码的两大处理方向：变长多字节编码以及宽字符。
- 变长多字节编码就是UTF-8和GBK，变长编码，在编码ASCII字符时使用单字节，编码中文时采用多字节
- UTF-8跟GBK又是不一样的编码方式，**不可混用**（UTF-8更通用，GBK只针对中文但更省内存）
- 宽字符就是采用4字节的固定宽度的宽字符编码
  - 宽字符对应的是`wchar_t`（区别`char`），以及`wstring`（区别`string`）
- C++11标准库提供了`<codecvt>`来转换编码（在C++17被弃用）
- `<windows.h>`提供了转换编码的工具函数
关于编码：
- 一个trick：根据utf8编码，原长0~7bit的ASCII字符的编码前缀都是0，也就是说，非ASCII字符的utf8编码一定是二进制下1开头的char，也就是说是*小于0的`signed char`*，或者*大于127地`unsigned char`*。这可以用来简单判断中文
  此外GBK编码的首字节同样是1开头的，类似的技巧也可以运用，但**尾字节不一定是1开头**
- 有一些拓展字符集（比如说表情包、emoji）是**gbk无法编码**的，此时UTF-8是唯一的选择

### 左值的本质

关于*左值*、*引用*、乃至*移动语义*的一系列关于C++变量的困惑的核心都是：**语义**

- “左值”
  
  一个C++变量至少具有两种属性（对应两层语义）：
  1. 变量的值；
  2. 变量所占用的空间；
  
  我们期待，**出现在赋值符号的左边的标识符要具备以上两种属性**。因为赋值运算的本质是：将某一个值放进一个存储空间里边。我们为具备这样属性的编程实体取名为**左值**。

  C++变量是典型的左值，但左值不一定要是变量名。因为左值因为具备以上两层含义的实体很多，比如：
  - 数组的下标访问
  - 指针的解引用
  - 函数返回的（非const）左值引用
  
  这一层面的理解解决了关于引用传参和引用返回值的困惑：
  - 我们使用引用传参时，我们不仅传递了值，还传递了值所在的储存空间的信息
  - 我们返回引用参数时，我们不仅返回了值，还返回了值所在的储存空间的信息

### 坑点
- Windows下一切系统调用一旦涉及中文，**必须采用GBK**（比如传递给fopen和ifstream的路径，若路径来自UTF-8编码的文件或应用或者采用保存为UTF-8格式的源代码的字符串字面量，则会出问题）
- switch陷阱：由于`switch`语句里面的`case`其实全是跳转的tag，本质上是同一个代码快，所以在不同`case`里面变量可能会重复初始化，且有可能跳过初始化之类。总之不要再`case`里面初始化变量
- ctime的时间处理：
  注意到ctime里的函数往往要传指针，其实这暗示了这些函数会*改变传入的量*，这导致非常多的bug，所以**不要持久保存传给ctime的变量**，因为其值不确定