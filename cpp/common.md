## 一般C++编程
### 全局变量
- 用函数返回值初始化全局变量/初始化对象从而调用构造函数是在main开始之前执行代码的方法。但要注意不同全局变量之间的初始化顺序是**不确定**的，小心相互依赖。
- 全局变量之可以定义一次，对应只分配一次全局区内存。多个文件中多次定义全局变量会导致重定义错误（除非使用static限定链接性）。但多个文件中使用全局变量要**声明**，语法是常规声明前面加extern如`extern int a`。声明要求本质上源于文件是*最小的编译单元*。
- 重定义的问题主要出现于在头文件中定义全局变量的做法。
- 函数定义有类似的问题，不要在头文件定义函数。
- 对于全局变量，正确做法是在头文件中写*声明*，在源文件中*定义*，然后链接
- 对于全局函数，两种做法：
  1. 头文件中*声明*，源文件中*定义*（标准做法）
  2. static定义
  3. inline（inline函数具有文件内的链接性）

### 列表初始化
C++11允许采用形如
```cpp
vector<int> vec = {1, 2, 3, 4};
map<int, string> = { {1, "a"}, {2, "b"} };
```
的列表初始化语法来初始化STL容器，可以大大方便容器的初始化。（上述语法中的等号可以省略）
还可以作为参数传递：
```cpp
map<int, string> mp;
mp.insert({3, "c"});
```

这种用法的奥秘在于：
1. 编译器的支持
2. initialize_list模板类支持变长的、任意类型的序列（尤其用于map这种每个项类型不一样的东西）

### 宏
宏可以用于移除一些重复代码，可以代码生成（语言体系内部不可替代），甚至用来编写DSL（慎）
用法：
- 分为一般宏和带参数宏
- 宏定义结尾不用写分号（如写上分号则当作是**宏体的一部分**），**一个宏定义只能写一行，多行情形必须加行连符号**
- 一般宏：
  - 使用`#define 宏名 宏体`定义
  - 宏体可以省略，常结合`#ifdef` `#ifndef`使用
  - 有部分预定义的宏如`__LINE__``__FILE__`分别表示所在行号、处理的文件名等
  - 可以由外部（如CMake等编译系统）传入用以在预处理阶段搞事（如条件编译）
- 带参数宏：
  - #的特殊用法：
  ```cpp
  #define STR(s) #s // 替换为"s"
  #define CONCAT(a,b) a##b // 替换为ab（连接起来）
  ```
  - 参数为宏时，这个宏会继续展开；特别地，宏体包含#用法时参数中的宏不会再展开，但可以通过一层间接宏来展开
  - 一个综合运用：
  ```cpp
  #define ___ANONYMOUS1(type, var, line) type var##line  
  #define __ANONYMOUS0(type,  line) ___ANONYMOUS1(type, _anonymous, line)  
  #define ANONYMOUS(type) __ANONYMOUS0(type, __LINE__)
  // 假设在第70行，ANONYMOUS(static int)展开为 static int _anonymous70
  ```

### 友元与继承
结论：友元与继承不能联合使用
解释：
- 基类友元不能访问子类私有
- 友元类子类同样没有访问特权

### 智能指针
- 智能指针不是普通指针的完全替代品，智能指针只用于**处理动态内存**的场合，在传参、迭代器、函数指针、多态等场合普通指针不能被其替代。
- 裸指针动态内存管理可以说是C/C++强大的根源之一，进程内对内存的管理完全自由，操作非常接近底层，允许非常底层的管理和优化，允许实现内存池之类自定义内存管理方案
- 裸指针的危害主要是：非法访问（“野指针”），内存泄露（动态内存没有得到回收），double-free（多次释放，试图释放别人的内存）
- 裸指针管理内存的不安全性的根源在于指针管理动态内存时，资源的管理是*任意的*，代码的*语义*是不明确的：
  - 在局部变量静态内存管理的场合，内存作为资源，其所有者是创建这个局部变量的函数，在函数返回时内存会自动回收，符合RAII，安全
  - 在动态内存场合，资源属于整个进程，进程内部对资源的管理是自由的、或者说是任意的，任何代码在任何位置都可以利用指针释放内存，但指向动态内存的指针的传递、访问都不受限制直至非法访问导致程序运行时错误。
  - 在动态内存场合，指向动态内存的指针有两种语义：弱引用和强引用
    - 弱引用是指**不具有资源的所有权**,**不负责管理内存**
    - 强引用**具有资源的所有权**，在引用失效时**负责回收内存**。
  - 裸指针的行为等效于*弱引用*，但指向动态内存的指针的*语义*是*不明确的*（也即两者皆有可能）
- 两种典型的智能指针：`unique_ptr<>` `shared_ptr<>`
  - 两种都是强引用，区别在于：`unique_ptr`在指针传递的同时移交所有权，在指针失效时就可以回收内存；`shared_ptr`进行引用计数，`shared_ptr`每次传递都使引用计数+1，资源在没有引用，也就是引用计数归0被回收。某种意义上来说，`shared_ptr`是`unique_ptr`的上位替代。
  - 但`shared_ptr`的引用计数方案存在循环计数的隐患。考虑堆上的两块内存相互引用，即使这两块内存都没有其他引用了，但引用计数都没法归0，也就是内存泄漏了。解决方法是引入`weak_ptr<>`，其在行为上与普通指针完全相同，也就是不进行引用计数，不影响资源的生命周期
