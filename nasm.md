## NASM
### 寻址
x86汇编的指令操作数（operand）允许如下形式：
- 寄存器(reg)
- 立即数(imm)
- 内存(mem)

最特殊的是内存操作数，这意味这x86指令可以直接与内存交互而不需要专门的load指令

内存操作数允许以汇编程序以灵活的方式寻址内存空间。内存寻址主要分为一下几种：
- 直接寻址:`[label]` `[imm]` `[expr]`
- 基址寻址:`[bx]` `[bp]`
- 变址寻址:`[si]` `[di]`
- 基址变址寻址:`[bx + si]` `[bx + di]` `[bp + si]` `[bp + di]`

直接寻址：

在方括号中放入立即数或者关于立即数的表达式可以寻址式子的值对应位置的内存。

直接寻址最典型的应用是访问特定标号对应的内存位置。（注意标号在NASM中等价于立即数）

此外，直接寻址允许写关于立即数的表达式而不只是立即数

基址寻址：

使用所谓的*基址寄存器*内的数进行内存寻址。**“基址寄存器”只包含这两个：`bx, bp`**

注：
- `bx`和`bp`的差别在于`bx`默认使用的段寄存器是`ds`（Data Segment)，而**`bp`默认使用`ss`(Stack Segment)**，也即`bp`常用于访问栈
- 可以加上立即数偏移
- 在32位保护模式下通用寄存器都可以作为基址寄存器

变址寻址：

使用*变址寄存器*内的数进行内存寻址。**“变址寄存器”只有两个：`si, di`**

注：
- `si`(Source Index)和`di`(Destination Index)可以配合`movsb` `movsw`使用
- 可以加上立即数偏移

基址变址寻址:

对内存寻址中组合直接寻址、基址寻址和变址寻址得到的寻址方式，也即形如`[bx + si + imm]`的表达方式

注：由于基址寄存器、变址寄存器，基址变址寻址在16位保护模式下使用的寄存器组合只有4种

其他注意：
1. 在32位保护模式下任何一个通用寄存器加上方括号都可以构成合法的间接寻址的内存操作数，但**16位实模式下只能使用SI,DI,BX,BP**（注意到SI,DI也称为变址寄存器）
2. 间接寻址可以是含立即数的表达式，比如`[esi+4*2]`是合法的，但16位实模式下寄存器前面不可以加系数
3. 内存操作数是**隐含段号的**，也即内存操作数中的地址只是*逻辑地址*，在加上`段号<<4`之后才是*线性地址*（在实模式下就是*物理地址*），且**默认使用ds中的段号**。如果要使用es中的段号，使用形如`[es:0x02]`或`[es:si]`的记号。

### IO

归根到底，计算机外界的所有IO设备无非都是数字设备硬件。访问IO设备的最底层手段是**读写硬件端口**。

所谓硬件端口，其实就是在做在IO线路上的寄存器。例如Single Port ROM，往往有addr地址输入端口和dout数据输出端口。

x86系统通过两种方式来直接访问硬件端口：
1. 将端口映射到内存中，使用mov+内存寻址访问
2. 单独编址，使用*端口号*来访问硬件

下面仅讨论单独编址的情况
#### 硬盘IO
要访问硬件端口，需要使用指令`in/out`。

其中`in/out`只有少数可用的格式：
```asm
in ax/al, dx
in ax/al, imm
out dx, ax/al
out imm, ax/al
```
其中，`dx`或者用于指示*端口号*，而`ax/al`用于放置输入端口的数/端口输出的数。`al`对应8位端口，`ax`对应16位端口

注意，**`in/out`不可以使用其他通用寄存器或者内存操作数！**

硬盘编址：
- CHS：传统方案，通过指定磁头号、柱面号、扇区号来读硬盘
- LBA：逻辑硬盘地址，以扇区为基本单位（每扇区512字节），使用一个数（也成为*逻辑扇区号*）来寻址特定扇区。老式的LBA28使用28比特逻辑扇区号，可以寻址128GB空间；现在常用的LBA48使用48比特，一般足够用了

读硬盘方案：
- 假设使用LBA28
- 一共有8个端口，包括7个8位端口，端口号`0x1f1~0x1f7`，以及一个16位端口`0x1f0`
- `0x1f2`指定读多少个扇区
- `0x1f3~0x1f6`指定28bit目标逻辑扇区号
- `0x1f6`端口的高4bit用于指定使用LBA还是CHS、以及是主硬盘还是从硬盘
- `0x1f7`既是命令端口，又是状态端口，向`0x1f7`发送`0x20`表示请求读；检查`0x1f7`端口可以检查硬盘是否忙、是否就绪、是否发生错误
- `0x1f0`是16位数据端口
- `0x1f1`是错误端口，表示错误信息

### BIOS

BIOS(Basic Input Out System)是硬件出场时写死在硬件的ROM中的程序，有时又称为*固件*

调用BIOS是除了直接访问硬件端口以外与硬件交互的最主要手段。通过使用*BIOS软中断*来调用BIOS的服务

触发软中断的指令是`int`

BIOS程序仍然只是软件，它同样需要通过访问硬件端口来与硬件交互，故在必要的时候完全可以**越过BIOS操作硬件**，比如直接写显存来显示

BIOS程序不全是由CPU或者主板提供的。许多硬件自己会提供硬件访问的固件代码。因此如非必要，直接使用BIOS访问硬件是好的做法

### 关于标号的汇编地址计算

无论当前汇编代码段被加载到什么内存地址，NASM汇编标号**总是假设从程序起始开始计算偏移**。这一特性一方面会导致标号的问题，另一方面可以用于计算程序总长

使用`SECTION vstart=`子句可以改变这一行为，比如：

```asm
SECTION code vstart=0
```

表示code段内的标号为相对段起始地址开始计算的偏移，且认为段起始地址为0

注意：**vstart子句不改变段在内存中的位置**！！事实恰好相反，vstart必须依照段被加载的实际行为正确设置才能使标号有正确的行为，如MBR的`vstart`：

```asm
SECTION mbr vstart=0x7c00
```

通常MBR只有一个段，之所以设置为`vstart=0x7c00`是因为BIOS真正的行为恰恰是将MBR程序载入到物理地址0x07c00处，故如此设置才能使标号对应正确的内存地址

### jmp far
`jmp far`（远转移）用于跳转到当前段之外的位置。远转移的操作数可以是`imm:imm`形式的两个立即数，也可以是`[mem]`的间接操作数

注意，`jmp far`会根据目标地址，**同时修改IP和CS**

### ret、retf与栈
注意ret的行为等价于：
```asm
pop ip
```
retf的行为等价于：
```asm
pop ip
pop cs
```

依旧是说ret与retf*并不是一定与call成对使用*，可以通过认为修改栈来使用该行为

### 杂项
```asm
cs ; code segment
ds ; data segment
es ; segment
ss ; stack segment
bx ; a gereral register, also used as base register
jmp $ ; $ = current line
jmp $$ ; $$ = the start line of current segment

si ; source index reg.
di ; destination index reg.

rep movsb ; copy a series of byte
rep movsw ; copy a series of word

cld ; set movsb direction
movsx ; sign extension
movsz ; sero extension

; only four format valid!!
; [bx + si], [bx + di], [bp + si], [bp + di];

```

mov不可以直接向段寄存器放入立即数！

### div/mul
小心乘除法的操作！！！
乘法：（待完善）

除法：
- 两种方式：32位除以16位，以及16位除以8位
- 方式一：32位除以16位
  - 被除数`dx:ax`
  - 除数`reg16`
  - 商放在`ax`，余数放在`dx`
  - 谨慎使用`dx`作为除数（一般都不是你想要的结果）
- 方式二：16位除以8位
  - 被除数`ax`
  - 除数`reg8`如`al`
  - **商放在al，余数放在ah**，此时**将ax当作商很可能是错的**
