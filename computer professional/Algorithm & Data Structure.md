## Algorithm & Data Structure Note

### 比较排序算法时间下界
- 结论：$\Omega(nlogn)$
- 基于比较的排序

  若一个排序算法除了测试两个元素的相对大小关系之外，没有任何办法获得次序信息，则称这种算法为*基于比较的排序算法*

- 决策树
  
  由于比较排序算法获得次序的唯一方法是比较次序，故我们可以将算法的过程建模为一颗二叉决策树。

  （不失一般性，设元素互不相同）

  其中，决策树的内部节点表示一次元素的比较，左子节点表示$a_i \le a_j$情况下的下一步决策，右子节点表示$a_i > a_j$的情况

  决策树的每个叶子节点表示一个最终的排序决策。

- 证明比较排序时间下界

  设输入规模$n$，叶子节点数$l$，树高$h$，

  根据决策树性质，可以$T(n) = \Omega(h)$

  由于$A_n^n = n!$，一个正确的排序算法对于应该至少能生成$n!$种排序决策，也即**一个正确的排序算法的决策树叶节点数目至少为$n!$**

  再由二叉树叶子节点数的上界为$2^h$

  于是有：
  $$
    n! \le l \le 2^h
  $$
  也即
  $$
    \mathrm{T}(n) = h \ge lg(h!) = \Omega(nlgn)
  $$

  证毕

### Execise：三分取中划分优化

三分取中：随机选择三个数，取其中的中位数作为划分点

设$\mathrm{rank}(a_i)$表示$a_i$排名，设满足$n/3 \le \mathrm{rank}(a_i) \le 2n/3$的$a_i$为一个“好的划分”，求$n\to \infty$时，三分取中划分比随机选择划分选得一个“好的划分”的概率增加多少？

答案：2/9

（待完善）


### Execise：k路合并时间分析
设$N为总节点数，k为链表数$

算法1：按链表长度由短到长合并：$O(kN)$

算法2：堆优化k路合并：$O(N\lg k)$

算法3：按秩合并：$O(N\lg k)$

算法3的分析：
- 按秩合并是指进行k-1次二路合并，每次选择长度最短的两个链表，合并所得再次进入备选合并链表中
- 该算法的分析可以参考**哈夫曼编码最长编码长度**的分析，可知：
  
  最长编码长度$\sum_{i=1}^k p_i \lg(1/p_i) + 1$，然后$p_i$取$1/k$得$\lg k$
  

- 详细证明：
  
  考虑$k$个有序链表，共包含$N$个节点，链表的长度为$w_i$

  采用贪心策略合并的过程可以描述为一颗哈夫曼树，令对应叶节点概率$p_i = w_i / N$

  由哈夫曼树的定义有：
  1. 叶节点的概率为$p_i$，非叶节点的概率为子节点概率之和
  2. 树根的概率为1
  3. 节点的概率值不大于高度比它低的节点
  
  设根节点到某一节点的路径长度为$L_i$

  引理1：
  $$
    p \le \left(\frac{1}{2}\right)^{L-1}
  $$
  也即
  $$
  L \le \lg \frac{1}{p} + 1
  $$
  
  下证引理1：

  用反证法，假设$p > (1/2)^{L-1}$，由哈夫曼树性质1和3，其父节点以及父节点的兄弟的概率$p_{f} > (1/2)^{L-1}$，也即其祖父节点概率有$p_{gf} > (1/2)^{L-2}$，应用归纳法得根节点$p_{\mathrm{root}} > 1$，与哈夫曼树性质2矛盾，证毕

  设节点对应的哈夫曼树上路径长度为$L_i$
  由引理1得最大编码长度：
  $$
    L_{\mathrm{sum}} = \sum_{i} p_i L_i \le \sum_{i} p_i \lg \frac{1}{p_i} + 1
  $$

  又由：
  - $w_i$对应链表长度
  - $p_i = w_i / N$
  - $L_i$对应链表被合并次数
  
  得问题上界：
  $$
    T(N,k) = \sum_{i=1}^{k} w_i L_i = N L_{\mathrm{sum}} \\
    \le N\left(\sum_{i=1}^k p_i \lg \frac{1}{p_i} + 1\right) \\
    \le  N k\cdot \frac{1}{k} \lg k + N \\
    = O(N\lg k)
  $$

  其中，取最坏情况：“所有链表等长”来放缩

  按秩合并时间复杂度证毕