# Algorithm & Data Structure Note

## 比较排序算法时间下界
- 结论：$T = \lceil n log n\rceil = \Omega(nlogn)$
- 基于比较的排序

  若一个排序算法除了测试两个元素的相对大小关系之外，没有任何办法获得次序信息，则称这种算法为*基于比较的排序算法*

- 决策树
  
  由于比较排序算法获得次序的唯一方法是比较次序，故我们可以将算法的过程建模为一颗二叉决策树。

  （不失一般性，设元素互不相同）

  其中，决策树的内部节点表示一次元素的比较，左子节点表示$a_i \le a_j$情况下的下一步决策，右子节点表示$a_i > a_j$的情况

  决策树的每个叶子节点表示一个最终的排序决策。

- 证明比较排序时间下界

  设输入规模$n$，叶子节点数$l$，树高$h$，

  根据决策树性质，可以$T(n) = \Omega(h)$

  由于$A_n^n = n!$，一个正确的排序算法对于应该至少能生成$n!$种排序决策，也即**一个正确的排序算法的决策树叶节点数目至少为$n!$**

  再由二叉树叶子节点数的上界为$2^h$

  于是有：
  $$
    n! \le l \le 2^h
  $$
  也即
  $$
    \mathrm{T}(n) = h \ge lg(h!) = \Omega(nlgn)
  $$

  证毕

## Execise：三分取中划分优化

三分取中：随机选择三个数，取其中的中位数作为划分点

设$\mathrm{rank}(a_i)$表示$a_i$排名，设满足$n/3 \le \mathrm{rank}(a_i) \le 2n/3$的$a_i$为一个“好的划分”，求$n\to \infty$时，三分取中划分比随机选择划分选得一个“好的划分”的概率增加多少？

答案：2/9

（待完善）


## Execise：k路合并时间分析
设$N为总节点数，k为链表数$

算法1：按链表长度由短到长合并：$O(kN)$

算法2：堆优化k路合并：$O(N\lg k)$

算法3：按秩合并：$O(N\lg k)$

算法3的分析：
- 按秩合并是指进行k-1次二路合并，每次选择长度最短的两个链表，合并所得再次进入备选合并链表中
- 该算法的分析可以参考**哈夫曼编码最长编码长度**的分析，可知：
  
  最长编码长度$\sum_{i=1}^k p_i \lg(1/p_i) + 1$，然后$p_i$取$1/k$得$\lg k$
  

- 详细证明：
  
  考虑$k$个有序链表，共包含$N$个节点，链表的长度为$w_i$

  采用贪心策略合并的过程可以描述为一颗哈夫曼树，令对应叶节点概率$p_i = w_i / N$

  由哈夫曼树的定义有：
  1. 叶节点的概率为$p_i$，非叶节点的概率为子节点概率之和
  2. 树根的概率为1
  3. 节点的概率值不大于高度比它低的节点
  
  设根节点到某一节点的路径长度为$L_i$

  引理1：
  $$
    p \le \left(\frac{1}{2}\right)^{L-1}
  $$
  也即
  $$
  L \le \lg \frac{1}{p} + 1
  $$
  
  下证引理1：

  用反证法，假设$p > (1/2)^{L-1}$，由哈夫曼树性质1和3，其父节点以及父节点的兄弟的概率$p_{f} > (1/2)^{L-1}$，也即其祖父节点概率有$p_{gf} > (1/2)^{L-2}$，应用归纳法得根节点$p_{\mathrm{root}} > 1$，与哈夫曼树性质2矛盾，证毕

  设节点对应的哈夫曼树上路径长度为$L_i$
  由引理1得最大编码长度：
  $$
    L_{\mathrm{sum}} = \sum_{i} p_i L_i \le \sum_{i} p_i \lg \frac{1}{p_i} + 1
  $$

  又由：
  - $w_i$对应链表长度
  - $p_i = w_i / N$
  - $L_i$对应链表被合并次数
  
  得问题上界：
  $$
    T(N,k) = \sum_{i=1}^{k} w_i L_i = N L_{\mathrm{sum}} \\
    \le N\left(\sum_{i=1}^k p_i \lg \frac{1}{p_i} + 1\right) \\
    \le  N k\cdot \frac{1}{k} \lg k + N \\
    = O(N\lg k)
  $$

  其中，取最坏情况：“所有链表等长”来放缩

  按秩合并时间复杂度证毕


## 二叉堆常用数学关系
假定使用数组表示二叉堆，且下标从1开始，元素长度为n
$$
  最后一个内部节点的下标：\lfloor \frac{n}{2}\rfloor\\
  也即：第一个叶子节点：\lfloor \frac{n}{2} \rfloor + 1\\
  （由n = 2x或n = 2x+1得到）
$$

$$
  堆的树高 
$$

## 关于折半取整运算：
$$
  \lfloor \lfloor n / 2 \rfloor / 2 \rfloor = \lfloor n / 4 \rfloor
$$
该证明考虑$n=4nk, 4k+1, 4k+2, 4k+3$即可得证

对向上取整可以有类似的结论

此外有如下结论：
$$
  \lfloor \lceil n / 2 \rceil / 2 \rfloor = \lfloor n/4 \rfloor\\
  \lceil \lfloor n / 2 \rfloor /2 \rceil = \lceil n/4 \rceil
$$

发现对于折半操作，嵌套的向上/向下取整运算可以只保留最外面一层

然后用数学归纳法即可推广到任意次迭代运算

关于该结论，我们有如下推广：

折半查找的最长查找路径与最短查找路径之差至多为1（当数组长度不是2的整数幂的时候差1）

具体地，我们有：
$$
  h = h_{max} = \lceil \log_2 n \rceil  + 1 \\
  h_{min} = \lfloor \log_2 n \rfloor + 1
$$

## SPFA相关证明
证明：在SPFA中，若一个图包含n个节点，一个节点入队不少于n次等价于该图存在负权回路
（待完善）

## 算术算法及其复杂度
以下算法中$n$都表示参与运算的数字的二进制位数
- 加法：
  
  行波进位加法器：$O(n)$

  先行进位加法器：$O(1)$

  级联的局部先行进位加法器：$O(logn)$

  可以通过补码实现，等价于加法

- 乘法：

  朴素做法：$O(n^2)$

  其他优化比这个快，比如阵列乘法器（待完善）

- 除法：$O(n^2)$
- 模运算下的算术复杂度与常规类似，除了**模运算下的除法，复杂度$O(n^3)$**
- 模运算下的幂运算：快速幂
  
  考虑求$x^y \mod N$，采用朴素乘法的复杂度是$O(n^2 2^n)$，不可接受，且会溢出

  采用快速幂的复杂度是$O(n^3)$（假设乘法是$O(n^2)$）

## 数论算法
- 欧几里得算法
  ```c
  int gcd(int a, int b){
    return b == 0 ? a : gcd(b, a % b);
  }
  ```
  复杂度$O(logn)$。如果$n$表示位数，乘法复杂度$O(n^2)$，则欧几里得的复杂度为$O(n^3)$

- 扩展欧几里得
  
  贝祖定理：
  $$
    关于x,y \in Z的丢番图方程ax+by=d有解\\\Leftrightarrow gcd(a,b) | d\\
    其中a,b \in Z^+
  $$

  有了贝祖定理保证，我们有扩展欧几里得算法，用于对给定的$a,b$，求方程：
  $$
    ax + by = gcd(a,b)
  $$
  的解$x,y$

- 乘法逆元

  定义：
  $$
    a在模M下的乘法逆元x满足：\\
    ax \equiv 1 \pmod M
  $$

  动机：

  为了求同余除法，我们把除一个数转换为乘一个数的逆元。也是因为这个，$n$位二进制数求模运算下的除法需要$O(n^3)$而不是$O(n^2)$

  **注意：乘法逆元不一定存在**。$a$在模$M$下存在乘法逆元的充要条件是$a, M互质$

  若满足$gcd(a,M)=1$，则可以使用扩展欧几里得求乘法逆元：
  $$
    ax \equiv 1 \pmod M \\
    \exist y\in Z\Leftrightarrow ax = My + 1 \\
    \exist y\in Z\Leftrightarrow ax + My = 1
  $$
  然后求解方程$ax + My = 1$得逆元$x$即可

  特别地，若模$p$是素数，则我们可以采用基于*费马小定理*，用快速幂取模来求乘法逆元：
  
  *费马小定理*：
  $$
    若p是素数，则a^{p -1} \equiv 1 \pmod p\\
  $$

  变形得：
  $$
    a^{p-2} \equiv a^{-1} \pmod p
  $$
  快速幂求$a^{p-2} \mod p$即可

- Primarity Test
  
  **费马小定理**：
  $$
    若p是素数，p\nmid a，则a^{p -1} \equiv 1 \pmod p\\
  $$

  *费马测试*：
  对$a<N$, $N \in N^+$，若
  $$
    a^{N-1} \equiv 1 \pmod N
  $$
  成立，则$N$通过测试，否则不通过。

  注意：**不通过费马测试的必定是合数，但通过费马测试的不一定是质数**

  这是因为**费马小定理的条件是充分不必要的**，即$\exist N$为合数，使得$a^{N-1} \equiv 1 \pmod N$成立。更极端的例子是Carmichael Number: $\forall a < N , gcd(a, N) = 1$，有$a^{N-1} \equiv 1 \pmod N$成立。$N$就是一个Carmichael数。561是最小的Carmichael数

  但是，我们可以证明对非Carmichael的合数，满足$a^{N-1} \equiv 1 \pmod N, 1 \le a < N$的数$a$只有小部分

  现在，先不考虑Carmichael数，对正整数$N$，我们有如下断言：
  1. if $N$ is a prime, $a^{N-1} \equiv 1 \pmod N, \forall a < N$
  2. if $N$ is not prime, 至多一半的$a < N$能满足$a^{N-1} \equiv 1 \pmod N$
  
  有了上述断言保证，我们可以设计概率算法进行大数的Primarity Test：反复选取$a < N$，$a$是素数，合数$N$能通过费马测试会指数级减小。具体地，一个合数通过$k$个素数的费马测试的概率是$1/2^k$

- 素数定理

- **欧拉函数与欧拉定理**：

  令$\phi(n)$表示比$n$小的且与n互质的正整数的个数，$\phi(n)$即时欧拉函数

  关于欧拉函数有如下一些重要事实：
  
  1. $\phi(n) = n(1-1/p_1)(1-1/p_2)\cdots(1-1/p_k)$ 其中，$p_i$表示$n$的质因子
  2. $\phi(nm) = \phi(n)\phi(m)$，即欧拉函数是*积性函数*
  3. $\phi(p) = p - 1$, $p$ is a prime
  4. **欧拉定理**：
    $$
      \forall a < n: gcd(a,n) =1, \\
      a^{\phi(n)} \equiv 1 \pmod n
    $$

    由此可见，费马小定理是欧拉定理的特例
  
  事实上，对于并不大的$n$计算$\phi(n)$的最好方法是*欧拉筛*

## RSA公钥加密算法
  
对称加密算法最大的困难是*如何交换密钥*。非对称加密算法解决了这个问题，其中RSA公钥加密算法是最有代表性的。

RSA的安全性由“目前没有高效的大数因子分解算法”来保证

密钥构造基本步骤：
1. 选取两个质数$p,q$，令$n = pq$，则$\phi(n) = (p-1)(q-1)$（积性函数）
2. 对于待加密信息$x$，$x < n$，我们选取一个$e$满足$e < \phi(n), gcd(e,\phi(n)) = 1$，然后求$e$关于模$\phi(n)$的逆元$d$
3. 二元组$(n,e)$即是公钥，$(n,d)$即是私钥

加密函数：$E_{(n,e)}(x) = x^e \mod n$

解密函数：$D_{(n,d)}(x) = x^d \mod n$

解密算法正确性的证明：

要证明解密算法正确，即证：
$$
  c^d \equiv m \pmod n\\
  \mathrm{where}\ m^e \equiv c \pmod n
$$

$m$代表明文，$c$代表密文，$m < n$

由$m^e \equiv c \pmod n$有$c = m^e - kn$

故只要证$(m^e - kn)^d \equiv m \pmod n$

即证$m^{ed}\equiv m \pmod n$

由$ed \equiv 1 \pmod {\phi(n)}$可知，只要证：
$$
  m^{h\phi(n)+1} \equiv m \pmod n
$$

其中$h\in Z$

接下来分类讨论

1. $gcd(m,n) = 1$

   则$m^{\phi(n)} \equiv 1 \pmod n$（欧拉定理），则
   $$
    m^{h\phi(n)} \equiv 1 \pmod n\\
    m^{h\phi(n)+1} \equiv m \pmod n
   $$
   原式得证

2. $gcd(m,n) \ne 1$
   
   （待完善）


安全性：我们可以发现，如果需要从公钥$(n,e)$逆向计算私钥$(n,d)$，则需要对$n$做因数分解，若$n$非常大，则该分解在计算上不可解。

但RSA的问题在于无法证明“逆向求解私钥”问题具有与“大数分解”相同的难度。有研究者认为逆向求解私钥并没有大数分解那么难。

低指数攻击：当公钥指数$e$取得太小（比如3）的时候，可以越过私钥直接解密出明文（待完善）

## Divide and Conque （分治法）

### 改进算术乘法：分治

从复数乘法开始：
$$
(a + bi)(c+di) = ac - bd + (ad + bc)i
$$

一共要执行4次乘法

构造：
$$
  p_1 = (a+b)c\\
  p_2 = (a-b)d\\
  p_3 = a(c-d)
$$
则
$$
  p_2+p_3=(ac-bd)\\
  p_1-p_3=(ad+bc)\\
$$
从而可以以增加加法次数为代价，将乘法的次数减少至3次

现在，考虑将两个二进制数表示为形如$a\cdot 2^k +b, c\cdot 2^k + d$的形式

设$n$表示参与乘法的数的二进制位数。由于乘2的幂只需要移位，计算这两个数的乘积的所需时间：
$$
  T(n) = 3T(n/2) + O(n)
$$

由主定理可以立刻得到：
$$
  T(n) = O(n^{\log_23})
$$

优于朴素的$O(n^2)$乘法

实际上，硬件实现的乘法可以比这还要好，而且不是使用分治法，而是*阵列乘法器*。这是由于数字电路实现的硬件具有天然的并行性。

阵列乘法器的大致原理：

考虑两个$n$位二进制数，则朴素乘法需要考察乘数的每一位，然后将被乘数移位相加，复杂度$O(n^2)$

阵列乘法器可以**通过与门同时计算被乘数与乘数每一位的积**，并简单地执行移位相加，复杂度是$O(n)$（假设移位和加法使用朴素实现）甚至是$O(\log n)$（优化的移位寄存器和部分线性进位的加法器）。

但这种做法和先行进位加法器有同样的问题：在$n$很大的时候硬件开销大得无法接受。于是采用和线性进位加法器相同的解决方法：部分阵列，然后级联。最终得到的乘法器复杂度是$O(n\ logn)$

