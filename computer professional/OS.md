## Operating System
### x86计算机启动流程

x86计算机启动流程：

1. 上电，BIOS，
   
   处理器上电后**立刻执行烧写在某ROM芯片中的BIOS程序**。BIOS程序进行上电自检、初始化最基本的硬件设备并**载入并执行启动盘的起始512字节代码**。

   说明：
   1. BIOS是固件的一种，是硬件出厂的时候写在ROM里的一小段程序，CPU被设计为上电就会自动执行这段程序。这段程序会初始化最基本的硬件设备，包括启动盘、内存、显示器、键盘（甚至鼠标）
   2. 启动盘的起始512字节可执行代码是无操作系统平台约束的x86裸代码，称为**bootloader**
   3. BIOS是统称，实际上现在采用的BIOS是UEFI

2. Bootloader

   启动盘起始512字节负责将完整的引导启动程序载入内存并**引导启动操作系统**
   
   说明：
   
   bootloader而在Windows平台下又称为MBR（主引导记录）。这是因为实际上512字节往往不足以完成全部载入工作，故这512字节做的事其实是把完整的引导启动程序载入到内存并执行。

    bootloader承担着如下任务：
    - **载入操作系统内核**：在启动盘中定位内核位置并载入到内存中
    - **切换至32位/64位保护模式**：x86 CPU启动的初始状态是**16位实模式**。该模式下程序直接访问物理内存，没有进程、多任务，但只能寻址1MB的内存空间。需要bootloader将CPU切换至保护模式，从而支持现代计算机的众多特性（段页式虚拟内存管理，进程管理等）
    - 将某些BIOS得到的硬件信息转交给OS

    实际上Linux的多系统引导程序Grub也就是一个bootloader，但Grub较为复杂，可以引导不同的操作系统的启动


### 自学笔记：中断

现代CPU允许外部设备以某种方式触发*中断*来使CPU暂停当前指令的执行、保存上下文并切换PC指针至特定的位置。通常中断后CPU会切换至*中断处理程序*处继续执行命令，并通常在中断处理程序完成后通过恢复保存的上下文来返回中断的点继续执行。

“中断”二字具有误导性，除了异常中断，通常“中断”其实是指*暂停*当前的控制流并执行中断处理程序，最后恢复到原来的控制流。

中断机制的作用在于**避免轮询，通过异步提高处理器利用率**。

具体来说，假设没有中断机制，再CPU执行到IO相关指令后，需要发送信号到IO模块，并反复检查IO模块的状态寄存器（也即*轮询*）以确定IO模块是否完成了工作，并在IO模块完成工作后开始读/写IO模块缓冲区的数据，再继续执行。这一轮询过程中CPU是始终在没有意义地忙的，因为轮询的实质是“等待完成”，表现在程序执行上就是*阻塞*。偏偏IO设备的速度往往远低于CPU，故轮询会造成巨大的CPU资源浪费。

例如：

> 常见家用机械硬盘是7200转/s的，故磁碟旋转半周需要4ms，耗时约400万CPU周期，若不使用中断，读取硬盘数据的过程中，CPU不得不等待机械硬盘寻道读取数据再写入到缓冲区，CPU才能读取，这是巨大的浪费。

中断机制允许采用如下机制：CPU向硬盘控制器发出读信号后，不作轮询，继续执行接下来的程序。硬盘控制器在完成读盘后，触发CPU中断，CPU暂停当前指令流，执行中断处理程序读入硬盘缓冲区里的数据，最后恢复指令流继续执行。

一个合适的类比是**回调**。中断机制可以看作允许CPU为IO操作注册“回调”。（实质上回调机制最有效的应用场景之一正是基于硬件中断的IO复用）

常见的中断类型：
- 程序中断：也称“异常”，即程序执行了不合法的操作
- 硬件故障中断
- **IO中断**：由IO控制器产生，用以通知CPU完成了某IO操作。举例：磁盘读写，网络通信，打印
- **时钟中断**：CPU内部计时器产生，用来实现“定时类”功能。

中断机制的一个很好的案例是Nginx的异步IO复用。（待完善）

### Process
- Process Image = Code Segment + Data Segment + Stack Segment + Process Control Block(PCB)
- PCB
  - pid（可能还有ppid,uid）
  - state: running/ready/blocked
  - priority
  - Program Counter (PC)
  - memory pointers: 内存相关指针
  - context: registers
  - IO information: such as file descriptors
  - accounting information: 进程相关统计信息
  - 注意，PCB中memorgy pointers + context + IO info.对应管理的资源可以看作一台逻辑上完整的计算机的全部资源。这暗示了进程运行相互独立相互隔离的特点
- 进程状态模型
  - 二状态模型
    - 最基本的模型，进程分别为运行态和等待态
    - 过于简单
  - 五状态模型
    - 进程分为*运行态*、*就绪态*和*阻塞态*，以及方便管理的起始态和结束态
    - *运行态*表示进程正在运行
    - *就绪态*表示进程不在运行，但请求的资源都已就绪，只等调度器调入运行
    - *阻塞态*表示进程正在等待IO/其他资源，从而阻塞
  - 六状态模型/七状态模型
    - 结合虚拟存储器，可以在无状态模型上添加*挂起态*
    - 挂起态的进程不在运行，且进程映像被调出主存，存在辅存中
    - 设计挂起态的动机是解决主存容量不足，将长久不运行的进程移出主存，在需要的时候才调入
    - 不正确地使用挂起态可能会导致性能下降（缺页的时间代价很大）
    - 由于虚拟存储器地分页机制，不一定要把整个进程映像挪到辅存中，可以把一部分（部分页）放在辅存中
- 进程控制原语
  - 依赖OS的*原语*来实现进程的分发、状态切换等操作
  - 原语与常规程序偏度不同，原语是*原子操作*，不可以中断，否则会导致混乱
  - 一个常见的手法是通过不响应中断来实现原子性
  - 逻辑上来看，OS原语可以看作对ISA的扩充，增加了指令

### Process vs. Thread
- 进程是**资源分配的最小单位**
  - OS为进程分配pid、内存、fd表等资源，*不单独为线程分配这些资源*
  - 具有独立的PCB、特权级等
  - 进程可以是OS层面并发执行的较粗粒度。
- 线程是**调度执行的最小单位**
  - OS可以以线程为单位分配CPU时间。
  - 线程是OS层面并发执行的最小粒度。
  - 同一进程派生的多个线程**共享资源**，比如fd，内存地址空间等

### 用户级线程 vs. 内核级线程

用户级线程（ULT）
- 在用户级代码实现多线程
- 代表性的库是pthread
- 优点：
  - 不需要切换至内核态
  - 调度策略可以由应用程序定制
  - 可以跨平台
- 缺点：
  - 由于发起系统调用时进程被阻塞，只要有一个线程发起系统调用时，同一进程的所有派生的用户级线程都会阻塞
  - 在纯粹的用户级线程策略中，用户级线程无法利用多核
- 当然现在的ULT解决了部分缺点，比如说非阻塞的系统调用
  
系统级线程（KLT）
- 线程管理由内核完成，OS的调度以线程为单位
- 优点：
  - 线程阻塞不会导致进程阻塞
  - 充分发挥多核优势
- 缺点：
  - 线程调度切换需要内核介入，故有模式切换开销

还有混合ULT和KLT的方案（比如Solaris），在线程创建在用户态，线程调度和同步在内核态，此时ULT被映射到了若干个KLT

### 对称多处理SMP：同构

SMP 对称多处理是指**有多个具有相同功能的逻辑上的处理器**， 也即*同构*多处理器技术（区别异构）

多核处理器是SMP的一种实现，又称为*片上SMP*

### Windows进程模型

Windows系统思想：**一切皆资源/一切皆对象**。所有的资源都表示为对象(object)，然后使用句柄(handle)来管理。进程是占用资源的基本单位，一个进程的句柄表包含该进程拥有的资源，比如打开的文件、代码段、数据段，和*线程对象*。（由此可见，Windows下进程和线程是截然不同的逻辑实体）

Windows对象具有*属性*和*服务*（方法），许多时候，Windows的进程/线程属性对标的就是进程模型的PCB/TCB

### Linux进程模型
Linux的设计思想：**一切皆文件**。因此Linux进程占有的资源主要表现为其“打开”的文件，或者说其*文件描述符表*

Linux实际上没有区分进程和线程

### Mac/iOS的GCD技术
Mac/iOS处理基本的内核即线程实现之外，还在OS中提供了更强大的自动线程管理功能。用户不需要显式使用OS API，而是使用拓展的C语言记号来标识需要并发的“块”，然后由OS来创建线程、管理线程，根据底层硬件的特性来调整策略。