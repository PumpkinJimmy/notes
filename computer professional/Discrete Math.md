# 离散数学
## 命题逻辑
- 命题变量
- 五个符号
- 等值演算
  - 布尔代数
  - 蕴含等值式
  - 双蕴含等值式
- 范式
  - 合取范式 & 析取范式
  - 极大项 & 极小项
    - 注意编码默认按照命题变量字母字典序
  - 主合取范式 & 主析取范式
- 推理的有效性
  - 定义
  - 自然推理系统
    - 假言推理
    - 假言置换
    - 化简
    - 附加
    - 析取三段式
    - 等值置换
  - 附加前提：结论为蕴含式
  - 附加前提：反证法
- 自然语言转命题逻辑

## 一阶逻辑
- 一阶谓词公式
  - 逻辑符号：个体变量、逻辑运算、量词符号
  - 非逻辑符号：谓词、函数、个体常量符号
- 解释、论域
  - 逻辑语言&元语言
- 量词与个体变量符号
  - 指示变量
  - 辖域
  - 约束出现，自由出现
  - 约束变量，自由变量
  - *个体变量符号的同一性、重命名
- 量词嵌套
- 闭公式
  - 闭公式的真值与个体指派函数无关
- 一阶逻辑等值演算
  - 命题逻辑的一阶逻辑替换
  - 约束变量改名
  - 量词否定等值式
  - 量词辖域收缩/扩张
    - 合取/析取
    - **蕴含的前提量词辖域扩张：反转**
    - 蕴含的结论量词辖域扩张：不变
  - 量词分配等值式
    - 全称对合取的分配
    - 存在对析取的分配
- 前束范式及其求解
- 一阶逻辑公式推理有效性
  - 命题逻辑推理有效性
  - 全称例化
  - 全称泛化
  - 存在例化
  - 存在泛化
  - 全称泛化1：例化为自由变量
      
    $\forall x A(x)$ 例化为$A(y)$时**要求$x$不在$A(x)$中的任何关于y约束的子公式中自由出现**。且**全称例化为个体变量时替换的是$A(x)$中自由出现的$x$**

    不满足要求的替换会导致关于$y$约束的某些子公式中凭空多出现约束变量，导致推理无效。

    注意**在$A(x)$中$y$自由出现不影响例化个体变量的选择$**

    实际操作中，只要保证$y$不在$A(x)$约束出现就总能使得推理成立

  - 全称例化2：例化为任何一个个体常量，但是同样**只能替换$A(x)$中自由出现的$x$**
  - 全称泛化：要求泛化时**全称量词使用的指示变量没有出现过**。注意原则上约束出现本来时不影响的，但这会导致辖域嵌套，所以实际操作中不允许这样的选择。

  - 存在例化：
    
    1. **存在例化只能选择上文没有出现过的个体常量**
    2. 存在例化公式$\exist xA(x)$时**要求$A(x)$中只有$x$一个自由变量**（比如存在例化$\exist x A(x,y)$为$A(c,y)$可能会导致推理无效）。实际上这一要求对于存在例化量词推理的有效是充分非必要的。
  
  - 存在泛化1：自由变量泛化为存在量词
    - 要求该自由变量没有在新添加的存在量词的指示变量的任何辖域中自由出现，类似全称例化1的要求
      
      同样，实际操作中选择没有在公式中出现过的个体变量即可
  
  - 存在泛化2：个体常量泛化为存在量词
    - 只要量词的指示变量没有出现过即可，类似全称例化2
    
  - 坑1：非前束范式例化
    - **不可以选择非前束范式的量词进行例化**（换句话说，不可以对子公式的量词例化/泛化）
      
      这一点要求的直接推论是，对多个量词的前束范式，例化要从左起第一个量词开始

  - 坑2：消除附加前提再泛化

## 证明方法
- 全称命题证明：直接证明&间接证明
  - “不失一般性”
  - 间接证明的典型：反证法
    
    $$
      A \rightarrow B \equiv A \wedge \neg B \rightarrow C \wedge \neg C
    $$
- 分情况证明
- 存在命题证明：构造性证明&非构造性证明
  - 构造性证明：直接给出使得命题为真的个体
  - 非构造性证明一：反证法
  - 非构造性证明二：二难推理

    若待证明的存在命题为$q$，则由逻辑等值式：
    $$
      q \equiv (p\rightarrow q) \wedge(\neg p \rightarrow q)
    $$

    可知：若无论命题$p$是否为真，都可以推出$q$，则$q$为真

    可见，二难推理的关键在于选取合适的前提$p$。通常，$p$是一个难以获知其真值的命题，故需要对$p$为真和$p$为假两种情况都做出证明。
- 唯一存在
  
  $$
    \exist!xP(x) \equiv \exist x(P(x) \wedge \forall y (P(y)\rightarrow x=y))
  $$

- 数学归纳法
  - 第一数学归纳法
    
    对命题$\forall x P(x)$：

    1. 证明$P(c)$成立
    2. 证明对$\forall k \ge c(P(k)\rightarrow P(k+1))$

  - 第二数学归纳法（强归纳法）
    
    对命题$\forall x P(x)$：

    1. 逐一证明$P(c),P(c+1),\cdots,P(c+j)$成立
    2. 证明$\forall k \ge c+j(P(c)\wedge P(c+1) \wedge \cdots \wedge P(k) \rightarrow P(k+1))$

    **注意：尽管假设命题从$c$到$k$都成立，但证明$k+1$成立时至多只能用$P(k-j)$到$P(k)$**

  - 第一第二数学归纳法的区别：
    
    **第一数学归纳法假设命题对$k$成立**，**第二数学归纳法加强了归纳假设，命题从$c$到$k$命题都成立**
  
  - 深入讨论第二数学归纳法：
    
    区别于第一数学归纳法，**作为加强归纳假设的代价，$P(c)$到$P(c+j)$都要单独验证**

    此外，名义上假设$P(c)$到$P(k)$都成立，但实际上，**为了保证$P(k-j)$的成立包含在归纳假设里边，必须保证$k-j\ge c$，也即$k \ge j + c$，这也是为什么需要单独验证到$P(c+j)$**. 本质上仍然是数学归纳法的多米诺骨牌效应，只要有了第一个骨牌（$P(c+j)$）倒下，后续的骨牌$P(k)$就都可以“倒下”了
    
    可以看到：作为可以使用更强的前提的代价，第二数学归纳法必须在归纳基部分证明更多的初始前提；而第一数学归纳法可以视作$j=0$的第二数学归纳法，第二数学归纳法兼容第一数学归纳法。
  
  - 自然数集的良序性质
    
    自然数集的任意子集都有最小元素称为自然数的*良序性质*。**数学归纳法的有效性与该性质等价**

  - 良序性质和数学归纳法本质上都源于自然数是归纳定义的。

- 良序性质证明

  要用良序性质证明$\forall n P(n)$，通常的手法是：
  
  1. 构造自然数的非空子集$S$
  2. 设集合$S$的最小元素为$d$
  3. 用反证法，假设$P(x)$不成立，利用$d$和$\neg P(x)$构造出$d' \in S$使得$d' < d$，与假设矛盾，从而$\forall n P(n)$得证

- 结构归纳法
  - 使用归纳基-归纳步的来定义集合。
  - 要证明$\forall s \in S (P(s))$，分两步：先证明对归纳基$P(s)$成立，然后假设归纳步中$P(s)$成立，证明$P$对由$s$构造的新元素也成立

## 集合
- 集合定义
- 集合运算
  - 交&并
  - 广义交&广义并
  - 补
  - 差
- 子集关系
- 集合恒等运算
- 子集恒等式

## 关系
- 笛卡尔积
- 关系的定义
- 关系的表示
  - 关系图
  - 关系矩阵
- 关系运算：
  - 关系的交、并、差、补
  - 关系复合
  - 逆关系
- 关系性质：
  - 自反性&反自反性
  - 对称性&反对称性
  - 传递性
- 关系闭包
  - 自反闭包：$R \cup \Delta_A$
  - 对称闭包：$R \cup R^{-1}$
  - 传递闭包：$\bigcup_{n=1}^{\infty} R^{n}$
  - Warshall算法求传递闭包
- 等价关系：自反&对称&传递
- 偏序关系：自反&反对称&传递
  - 极大元、极小元、最大元、最小元
  - 上界、下界、上确界、下确界
  - 哈森图
  - 全序关系

## 函数
- 函数的定义
  - 定义域
  - 陪域
  - 值域
  - 原像
  - 像
- 函数运算
  - 复合
  - 逆
- 函数性质
  - 单函数
  - 满函数
  - 双函数
- 函数性质与函数运算的关系
  - 双函数&逆
  - 单函数&左逆
  - 满函数&右逆